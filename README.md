[![Go Reference](https://pkg.go.dev/badge/github.com/dbgjerez/workshop-golang-grpc/comment.svg)](https://pkg.go.dev/github.com/dbgjerez/workshop-golang-grpc/comment)

// TODO: explain the objective of this workshop

# Installation

## protoc

**Download the binary to a temporal directory**

```bash
curl -L https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protoc-21.12-linux-x86_64.zip -o /tmp/protoc.zip
```

> NOTE: We'll use the "v21.12" version of protoc, which is the latest today. You can change it for another version that you can find in the following link, even though it's not necessary: https://github.com/protocolbuffers/protobuf/releases

**Unzip it**
```bash
unzip /tmp/protoc.zip -d /tmp/protoc/
```

**Install the binary**

```bash
mv /tmp/protoc/bin/protoc /usr/local/bin/protoc
```

**Verify the installation**

```bash
protoc --version
libprotoc 3.21.12
```

## protoc-gen-go and protoc-gen-go-grpc

```zsh
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

> NOTE: if you can execute ```protoc-gen-go``` you have to add it to your PATH: ```export GO_PATH=~/go``` and ```export PATH=$PATH:/$GO_PATH/bin```

# Generate protobufs

A significant advantage of using protobufs is the capacity to auto-generate the code in your preferred language, even in different languages. 

In this example, we're going to create a ```.proto``` file with the definition of the entity Comment. 

Once we've created the file, we'll generate the source code. In this case, I have chosen the golang plugin.

```zsh
protoc comment/grpc/*.proto \        
    --go_out=. \  
    --go_opt=paths=source_relative \
    --go-grpc_out=. \
    --go-grpc_opt=paths=source_relative
```

> NOTE: I've installed the ```protoc-gen-go``` plugin, which allow to auto-generate golang code. If you prefer, you can install it for another language.

After the plugin execution, we can inspect our code inside the ```comment/grpc``` folder.

# Create a project

As a good practice, we shouldn't modify the autogenerated code, but we can import and override it.

In this example we have the folder ```gprc``` which contains the generated code. We'll create a new module. This module are going to contains the auto-generated code and two applications, the grpc server and a grpc client to test our application. 

```bash
go mod init github.com/dbgjerez/workshop-golang-grpc/comment
```
> It's importat to use your own github account.

We need download the dependencies that our project need:

```bash
go mod tidy
go get google.golang.org/grpc
go get google.golang.org/grpc/reflection
```

Once we have our project, we'll create a folder called ```server``` and a ```main.go``` file inside, when we'll implement our server. 

The DDD structure used to organize this project has a folder for handlers. A handler is a point to communicate with our application, for example: a REST endpoint or gRPC like this case. In addition, the application domain has his folder for the domain. 

The main file contains all the necessary to initialize the application. The application initializes server, registers the gRPC handlers and starts up the server.

The main function looks like the following block: 

```go
func main() {
	flag.Parse()
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	s := grpc.NewServer()
	c.RegisterCommentServiceServer(s, handler.NewCommentHandler())
	c.RegisterHealthServer(s, new(handler.HealthHandler))
	c.RegisterInfoServiceServer(s, handler.NewInfoHandler())
	reflection.Register(s)
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
```

If we visualize the main.go file, we can watch the following points:
* The port when the application is listening.
* How the application starts the gRPC server.
* The registration of the comment service. 
* The registration of the health check service. 
* The registration of the info service. 

The line with ```reflection.Register(s)``` enables the exposition of the API, so you can call to know the different functions and endpoints that expose the application.

# Play with the application

Now, we can start our application and test it:

```bash
go run main.go
```

To test the application, we can use the ```grpcurl``` tool. For example, I'm going to list the different endpoints with the following command:

```bash
grpcurl -plaintext localhost:50051 list
CommentService
HealthService
InfoService
grpc.reflection.v1alpha.ServerReflection
```

> NOTE: change port 50051 for your application port. 

Our application responds in different endpoints, the first one is for our CommentService and the second one is the Reflection API.

If we continue calling we can see the different methods that contain our endpoint:

```bash
grpcurl -plaintext localhost:50051 list CommentService  
CommentService.Retrieve
```

We've received two methods, also the same that we defined in the ```comment.proto``` file. So, it looks good. Now, I'll call the insert method:

```bash
grpcurl -plaintext localhost:50051 CommentService.Retrieve 
ERROR:
  Code: Unimplemented
  Message: method Insert not implemented
```

Yeah, our application is responding, so it runs ok but we've received an error code. This error is because we have not implemented the different methods as we have used the auto-generated code, and we only have defined an empty struct for our server.

# Implement the server code
Now, we can implement the business logic application without modifiying the auto-generated code. For this example, I'm only going to return a list of comments, but you can use whatever you want in your application.

As we defined the server struct, we only have to define the Retrieve method:

```go
type CommentHandler struct {
	c.UnimplementedCommentServiceServer
	comments []*c.Comment
}

func (s *CommentHandler) Retrieve(ctx context.Context, rq *c.RetrieveRequest) (*c.Comments, error) {
	log.Printf("Request: %s", rq.String())
	return &c.Comments{Comments: s.FilterComments(rq.IdObject, rq.TypeObject)}, nil
}
```

> NOTE: The ```CommentHandler``` struct has to contains the ```UninmplementedCommentServiceServer``` and wath ever you need, as a base de date or something similar. 

Finally, we'll implement the rest of handlers for info and health endpoints in similar way. 

Now, we run the application again and test it by calling the Retrieve endpoint:

```bash
grpcurl -plaintext localhost:50051 CommentService.Retrieve
{
  "comments": [
    {
      "idComment": "1",
      "idObject": 12,
      "typeObject": "film",
      "idUser": 20
    },
    {
      "idComment": "2",
      "idObject": 12,
      "typeObject": "film",
      "idUser": 20
    }
  ]
}
```

And now, we can see how the application responds to the comment that we return.

# Create a client

A client is an application that consume some services or applications easily. 

When we generated the code, the plugin generates a client too, facilitating the client programming as we only have to focus to the business logic. 

```go
	idObj   = flag.Int("idObj", -1, "The object id")
	typeObj = flag.String("type", "", "The server host")

	comments, err := client.Retrieve(ctx, &c.RetrieveRequest{IdObject: int32(*idObj), TypeObject: *typeObj})
```

The complete code is in the ```main.go``` file in the client folder. 

# Using container as runtime

Using containers as runtime we earn a lot of adventages. In this case, we'll create a container to run our application. 

Firstly, we need a file that contains the steps to generate our runtime container.

In addition, another good practice is to use a container to build the application. The ```Containerfile``` contains two steps, one to build and another to run the application. 

We can check all the steps opening it. 

Finally, the container can be builded with the following instructions:

```bash
SERVICE_NAME=comment-service
VERSION=0.2
SERVICE_BUILD_TIME=$(date '+%Y/%m/%d %H:%M:%S')
podman build \
    --no-cache \
    --build-arg version=$VERSION \
    --build-arg serviceName=$SERVICE_NAME \
    --build-arg buildTime=$SERVICE_BUILD_TIME \
    -t quay.io/dborrego/$SERVICE_NAME:$VERSION \
    -f Containerfile
```